{"projectName":"problem_7_2","totalTests":2,"passed":2,"failed":0,"skipped":0,"coveredLines":137,"missedLines":72,"coveragePercentage":65.55,"moduleStatus":[{"name":"problem_7_2","totalTests":2,"passed":2,"failed":0,"skipped":0,"tests":[{"name":"setupData","status":"PASSED"},{"name":"testProcessingEventNotifications","status":"PASSED"}]},{"name":"problem_7_2.hub","totalTests":0,"passed":0,"failed":0,"skipped":0,"tests":[]}],"moduleCoverage":[{"name":"problem_7_2","coveredLines":23,"missedLines":35,"coveragePercentage":39.66,"sourceFiles":[{"name":"types.bal","coveredLines":[6],"missedLines":[17],"coveragePercentage":50.0,"sourceCode":"type DiscussionDetails record {|\r\n    string title;\r\n    string kind;\r\n    string affectedVersion;\r\n    int priority;\r\n|};\r\n\r\ntype HubResponse record {\r\n  string kind;\r\n  string title;\r\n  string action;\r\n  string[] labels;\r\n  string \u0027version;\r\n  string severity?;\r\n  string impact?;\r\n  string new_label?;\r\n};\r\n"},{"name":"utils.bal","coveredLines":[],"missedLines":[3,4,5,6,7,9,11,12,14,16,17],"coveragePercentage":0.0,"sourceCode":"function calculatePriority(string kind, string? impact, string? severity) returns int|error {\r\n    int priority;\r\n    if kind \u003d\u003d \"feature request\" {\r\n        priority \u003d 3;\r\n    } else if kind \u003d\u003d \"bug\" {\r\n        if severity is () {\r\n            return error(\"Unexpected payload\");\r\n        }\r\n        priority \u003d priorityMap.get(\"bug\").get(severity);\r\n    } else {\r\n        if impact is () {\r\n            return error(\"Unexpected payload.\");\r\n        }\r\n        priority \u003d priorityMap.get(\"improvement\").get(impact);\r\n    }\r\n    return priority;\r\n}\r\n\r\nmap\u003cmap\u003cint\u003e\u003e priorityMap \u003d {\r\n    \"bug\": {\r\n        \"high\": 1,\r\n        \"medium\": 2,\r\n        \"low\": 3\r\n    },\r\n    \"improvement\": {\r\n        \"significant\": 2,\r\n        \"low\": 3\r\n    }\r\n};\r\n"},{"name":"main.bal","coveredLines":[8,10,11,12,14,15,16,17,19,20,21,35,37,43,44,45,46,47,49,50,51,65],"missedLines":[23,24,25,27,28,29,30,32,33,34,39,40,41,53,54,55,57,58,59,60,62,63,64],"coveragePercentage":48.89,"sourceCode":"import ballerina/log;\nimport projzone/webhook;\n\nlistener webhook:Listener webhookListener \u003d new(port, orgName, projName, secret, hub);\n\ntable\u003cDiscussionDetails\u003e discussionDetails \u003d table [];\n\nservice webhook:BugDiscussionService on webhookListener {\n\n    remote function onDiscussionClosed(webhook:BugDiscussionEvent event) {\n        return;\n    }\n\n    remote function onDiscussionOpened(webhook:BugDiscussionOpenedOrCommentedEvent event) {\n        log:printInfo(\"[BugDiscussionService] Webhook recieved onDiscussionOpened\", event \u003d event);\n        if event.labels.indexOf(\"documentation\") is () {\n            return;\n        }\n        int priority \u003d priorityMap.get(\"bug\").get(event.severity);\n        discussionDetails.add({title: event.title, priority, kind: \"bug\", affectedVersion: event.\u0027version});\n    }\n\n    remote function onDiscussionCommented(webhook:BugDiscussionOpenedOrCommentedEvent event) {\n        return;\n    }\n\n    remote function onDiscussionLabeled(webhook:BugDiscussionLabeledEvent event) {\n        log:printInfo(\"[BugDiscussionService] Webhook recieved onDiscussionLabeled\", event \u003d event);\n        if event.labels.indexOf(\"documentation\") is () || event.new_label !\u003d\u003d \"documentation\" {\n            return;\n        }\n        int priority \u003d priorityMap.get(\"bug\").get(event.severity);\n        discussionDetails.add({title: event.title, priority, kind: \"bug\", affectedVersion: event.\u0027version});\n    }\n}\n\nservice webhook:ImprovementDiscussionService on webhookListener {\n\n    remote function onDiscussionClosed(webhook:ImprovementDiscussionEvent event) {\n        return;\n    }\n\n    remote function onDiscussionOpened(webhook:ImprovementDiscussionOpenedOrCommentedEvent event) {\n        log:printInfo(\"[ImprovementDiscussionService] Webhook recieved onDiscussionOpened\", event \u003d event);\n        log:printInfo(\"IndexOfDocumentation\", ind \u003d event.labels.indexOf(\"documentation\"));\n        if event.labels.indexOf(\"documentation\") is () {\n            return;\n        }\n        int priority \u003d priorityMap.get(\"improvement\").get(event.impact);\n        discussionDetails.add({title: event.title, priority, kind: \"improvement\", affectedVersion: event.\u0027version});\n    }\n\n    remote function onDiscussionCommented(webhook:ImprovementDiscussionOpenedOrCommentedEvent event) {\n        return;\n    }\n\n    remote function onDiscussionLabeled(webhook:ImprovementDiscussionLabeledEvent event) {\n        log:printInfo(\"[ImprovementDiscussionService] Webhook recieved onDiscussionLabeled\", event \u003d event);\n        if event.labels.indexOf(\"documentation\") is () || event.new_label !\u003d\u003d \"documentation\" {\n            return;\n        }\n        int priority \u003d priorityMap.get(\"improvement\").get(event.impact);\n        discussionDetails.add({title: event.title, priority, kind: \"improvement\", affectedVersion: event.\u0027version});\n    }\n}\n"}]},{"name":"problem_7_2.hub","coveredLines":114,"missedLines":37,"coveragePercentage":75.5,"sourceFiles":[{"name":"in_memory_hub.bal","coveredLines":[26,27,29,32,33,34,35,36,37,38,39,42,43,44,45,46,47,49,56,57,59,60,61,62,66,67,69,70,71,72,73,78,79,80,81,83,84,85,88,89,90,92,96,97,98,102,109,110,111,112,115,116,117,118,119,122,124,125,127,129,131,132,133,134,137,140,141,143,144,145,149,150,153,154,157,158,159,162,164,165,166,172,175,176,177,180,184,187,188,193,195,196,223,224,226,229,231,232,233,236,238,242,253,254,257,258,259,261,262,265,267,268,269,280],"missedLines":[53,93,99,104,170,181,182,189,190,199,200,201,204,205,207,208,209,210,214,215,218,220,243,245,246,248,250,251,255,263,271,272,273,275,277,278,279],"coveragePercentage":75.5,"sourceCode":"import ballerina/http;\nimport ballerina/time;\nimport ballerina/log;\nimport ballerina/websubhub;\nimport ballerina/task;\n\nisolated map\u003cwebsubhub:Subscription[]\u003e subscriptions \u003d {};\n\ntype ClientDetails [string, websubhub:HubClient];\n\nisolated map\u003cClientDetails[]\u003e dispatcherClients \u003d {\n    [BUGS_TOPIC] : [],\n    [IMPROVEMENTS_TOPIC] : [],\n    [FEATURE_REQUESTS_TOPIC] : [],\n    [ALL_TOPIC] : []\n};\n\nconst ALL_TOPIC \u003d \"http://projzone.com/gofigure/Connectors/events/all.json\";\nconst BUGS_TOPIC \u003d \"http://projzone.com/gofigure/Connectors/events/bugs.json\";\nconst IMPROVEMENTS_TOPIC \u003d \"http://projzone.com/gofigure/Connectors/events/improvements.json\";\nconst FEATURE_REQUESTS_TOPIC \u003d \"http://projzone.com/gofigure/Connectors/events/featurerequests.json\";\n\nfinal string[] \u0026 readonly individualTopics \u003d [BUGS_TOPIC, IMPROVEMENTS_TOPIC, FEATURE_REQUESTS_TOPIC];\n\npublic function startMessageConsumption() {\n    foreach string topic in individualTopics {\n        _ \u003d @strand {thread: \"any\"} start consumeMessages(topic);\n    }\n}\n\npublic function syncDispatcherState() returns error? {\n    while true {\n        foreach string topic in individualTopics {\n            readonly \u0026 websubhub:Subscription[]? subscribers \u003d retrieveAvailableSubscriptions(topic);\n            if subscribers is () {\n                lock {\n                    dispatcherClients[topic] \u003d [];\n                }\n                continue;\n            }\n\n            lock {\n                ClientDetails[] clientDetails \u003d retrieveValidClientDetails(subscribers, dispatcherClients.get(topic));\n                readonly \u0026 websubhub:Subscription[] newSubscribers \u003d retrieveNewSubscribers(subscribers, clientDetails);\n                foreach var subscriber in newSubscribers {\n                    websubhub:HubClient clientEp \u003d check new (subscriber);\n                    clientDetails.push([subscriber.hubCallback, clientEp]);\n                }\n                dispatcherClients[topic] \u003d clientDetails;\n            }\n        }\n    }\n}\n\nisolated function retrieveValidClientDetails(websubhub:Subscription[] activeSubscriptions, ClientDetails[] currentClientDetails) returns ClientDetails[] {\n    string[] availableCallbacks \u003d from websubhub:Subscription subscription in activeSubscriptions\n        select subscription.hubCallback;\n\n    return from ClientDetails clientDetails in currentClientDetails\n        where availableCallbacks.indexOf(clientDetails[0]) is int\n        select clientDetails;\n}\n\nisolated function retrieveNewSubscribers(websubhub:Subscription[] activeSubscriptions, ClientDetails[] currentClientDetails)\n        returns readonly \u0026 websubhub:Subscription[] {\n    string[] currentCallbacks \u003d from [string, websubhub:HubClient] [callback, _] in currentClientDetails\n        select callback;\n\n    websubhub:Subscription[] newSubscriptions \u003d from websubhub:Subscription subscription in activeSubscriptions\n        where currentCallbacks.indexOf(subscription.hubCallback) is ()\n        select subscription;\n    return newSubscriptions.cloneReadOnly();\n}\n\n// TODO: check how we can improve this while also maintaining message order to an acceptable extent.\n// Currently seems to lock dispatcherClients.\nfunction consumeMessages(string topic) {\n    while true {\n        readonly \u0026 websubhub:UpdateMessage? message \u003d poll(topic);\n        if message is () {\n            continue;\n        }\n        readonly \u0026 websubhub:ContentDistributionMessage payload \u003d {\n            contentType: message.contentType,\n            content: message.content\n        };\n\n        lock {\n            foreach ClientDetails clientDetails in dispatcherClients.get(topic) {\n                string callback \u003d clientDetails[0];\n\n                if !isSubscriptionAvailable(topic, callback) {\n                    continue;\n                }\n\n                websubhub:HubClient clientEp \u003d clientDetails[1];\n                websubhub:ContentDistributionSuccess|error response \u003d clientEp-\u003enotifyContentDistribution(payload);\n                if response is websubhub:SubscriptionDeletedError {\n                    removeSubscription(topic, callback);\n                }\n            }\n        }\n    }\n}\n\nisolated websubhub:UpdateMessage[] queue \u003d [];\n\npublic isolated function enqueue(readonly \u0026 websubhub:UpdateMessage message) {\n    lock {\n        queue.push(message);\n    }\n}\n\npublic function dequeue(string topic) returns readonly \u0026 websubhub:UpdateMessage? {\n    lock {\n        int? index \u003d ();\n        foreach [int, websubhub:UpdateMessage] [messageIndex, message] in queue.enumerate() {\n            if message.hubTopic !\u003d topic {\n                continue;\n            }\n\n            index \u003d messageIndex;\n        }\n        if index is () {\n            return;\n        }\n        return queue.remove(index).cloneReadOnly();\n    }\n}\n\npublic function poll(string topic, decimal timeout \u003d 10.0) returns readonly \u0026 websubhub:UpdateMessage? {\n    readonly \u0026 websubhub:UpdateMessage? message \u003d dequeue(topic);\n    if message is websubhub:UpdateMessage {\n        return message;\n    }\n\n    time:Utc expiryTime \u003d time:utcAddSeconds(time:utcNow(), timeout);\n\n    // https://github.com/ballerina-platform/ballerina-lang/issues/33535\n    while message is () \u0026\u0026 time:utcDiffSeconds(expiryTime, time:utcNow()) \u003e 0D {\n        message \u003d dequeue(topic);\n\n        lock {\n            if queue.length() \u003d\u003d 0 {\n                break;\n            }\n        }\n    }\n    return message;\n}\n\npublic isolated function isTopicAvailable(string topic) returns boolean {\n    return topic \u003d\u003d ALL_TOPIC || individualTopics.indexOf(topic) !is ();\n}\n\npublic isolated function isSubscriptionAvailable(string topic, string hubCallback) returns boolean {\n    lock {\n        if !subscriptions.hasKey(topic) {\n            return false;\n        }\n\n        websubhub:Subscription[] topicSubscriptions \u003d subscriptions.get(topic);\n\n        foreach websubhub:Subscription subscription in topicSubscriptions {\n            if subscription.hubCallback \u003d\u003d hubCallback {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n\npublic isolated function addSubscription(readonly \u0026 websubhub:Subscription subscriber) {\n    log:printInfo(\"Adding subscription\", topic \u003d subscriber.hubTopic, callback \u003d subscriber.hubCallback);\n    string topic \u003d subscriber.hubTopic;\n    lock {\n        string[] topics;\n\n        if topic \u003d\u003d ALL_TOPIC {\n            topics \u003d [];\n            topics.push(...individualTopics);\n        } else {\n            topics \u003d [topic];\n        }\n\n        foreach string relevantTopic in topics {\n            if subscriptions.hasKey(relevantTopic) {\n                subscriptions.get(relevantTopic).push(subscriber);\n                continue;\n            }\n\n            subscriptions[relevantTopic] \u003d [subscriber];\n        }\n    }\n}\n\npublic isolated function removeSubscription(string topic, string hubCallback) {\n    lock {\n        if !subscriptions.hasKey(topic) {\n            return;\n        }\n\n        websubhub:Subscription[] topicSubscriptions \u003d subscriptions.get(topic);\n        int? index \u003d ();\n\n        foreach [int, websubhub:Subscription] [subscriptionIndex, subscription] in topicSubscriptions.enumerate() {\n            if subscription.hubCallback \u003d\u003d hubCallback {\n                index \u003d subscriptionIndex;\n                break;\n            }\n        }\n\n        if index is () {\n            return;\n        }\n\n        _ \u003d topicSubscriptions.remove(index);\n    }\n}\n\npublic function retrieveAvailableSubscriptions(string topic) returns readonly \u0026 websubhub:Subscription[]? {\n    lock {\n        return subscriptions[topic].cloneReadOnly();\n    }\n}\n\nfunction init() returns error? {\n    task:Job job \u003d object {\n        public function execute() {\n            startMessageConsumption();\n            _ \u003d @strand {thread: \"any\"} start syncDispatcherState();\n        }\n    };\n\n    _ \u003d check task:scheduleOneTimeJob(job, time:utcToCivil(time:utcAddSeconds(time:utcNow(), 3)));\n\n}\n\nconfigurable int hubPort \u003d 9090;\n\nisolated service \"hub\" on new websubhub:Listener(hubPort) {\n    remote function onRegisterTopic(readonly \u0026 websubhub:TopicRegistration message)\n                                returns websubhub:TopicRegistrationSuccess|websubhub:TopicRegistrationError {\n        return error(\"Topics are fixed.\", statusCode \u003d http:STATUS_BAD_REQUEST);\n    }\n\n    remote function onDeregisterTopic(readonly \u0026 websubhub:TopicDeregistration message)\n                                returns websubhub:TopicDeregistrationSuccess|websubhub:TopicDeregistrationError {\n        return error(\"Topics are fixed.\", statusCode \u003d http:STATUS_BAD_REQUEST);\n    }\n\n    isolated remote function onUpdateMessage(readonly \u0026 websubhub:UpdateMessage message) returns websubhub:Acknowledgement|websubhub:UpdateMessageError {\n        if !isTopicAvailable(message.hubTopic) {\n            return websubhub:UPDATE_MESSAGE_ERROR;\n        }\n        enqueue(message);\n        return websubhub:ACKNOWLEDGEMENT;\n    }\n\n    isolated remote function onSubscriptionValidation(readonly \u0026 websubhub:Subscription message) returns websubhub:SubscriptionDeniedError? {\n        if !isTopicAvailable(message.hubTopic) || isSubscriptionAvailable(message.hubTopic, message.hubCallback) {\n            return websubhub:SUBSCRIPTION_DENIED_ERROR;\n        }\n    }\n\n    isolated remote function onSubscriptionIntentVerified(readonly \u0026 websubhub:VerifiedSubscription message) returns error? {\n        addSubscription(message);\n    }\n\n    isolated remote function onUnsubscriptionValidation(readonly \u0026 websubhub:Unsubscription message) returns websubhub:UnsubscriptionDeniedError? {\n        if !isTopicAvailable(message.hubTopic) || !isSubscriptionAvailable(message.hubTopic, message.hubCallback) {\n            return websubhub:UNSUBSCRIPTION_DENIED_ERROR;\n        }\n    }\n\n    isolated remote function onUnsubscriptionIntentVerified(readonly \u0026 websubhub:VerifiedUnsubscription message) returns error? {\n        removeSubscription(message.hubTopic, message.hubCallback);\n    }\n}\n"}]}]}