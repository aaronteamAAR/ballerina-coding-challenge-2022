{"projectName":"problem_7_1","totalTests":2,"passed":2,"failed":0,"skipped":0,"coveredLines":136,"missedLines":41,"coveragePercentage":76.84,"moduleStatus":[{"name":"problem_7_1","totalTests":2,"passed":2,"failed":0,"skipped":0,"tests":[{"name":"setup","status":"PASSED"},{"name":"testProcessingEventNotifications","status":"PASSED"}]},{"name":"problem_7_1.hub","totalTests":0,"passed":0,"failed":0,"skipped":0,"tests":[]}],"moduleCoverage":[{"name":"problem_7_1","coveredLines":23,"missedLines":3,"coveragePercentage":88.46,"sourceFiles":[{"name":"types.bal","coveredLines":[6,20],"missedLines":[],"coveragePercentage":100.0,"sourceCode":"type DiscussionDetails record {|\r\n    string title;\r\n    string kind;\r\n    string affectedVersion;\r\n    int priority;\r\n|};\r\n\r\ntype HubResponse record {\r\n  string name;\r\n  string kind;\r\n  string title;\r\n  string action;\r\n  string actor;\r\n  string time;\r\n  string[] labels;\r\n  string \u0027version;\r\n  string severity?;\r\n  string impact?;\r\n  string new_label?;\r\n};\r\n"},{"name":"main.bal","coveredLines":[4,5,12,14,15,16,17,18,21,23,24,25,28,30,31,34,36,37,39,40,41],"missedLines":[22,26,32],"coveragePercentage":87.5,"sourceCode":"import ballerina/log;\nimport ballerina/websub;\n\n@websub:SubscriberServiceConfig {\n    target: [\n        hub,\n        topic\n    ],\n    secret\n}\n\nservice /JuApTOXq19 on new websub:Listener(port) {\n\n    remote function onEventNotification(websub:ContentDistributionMessage event) returns error? {\n        map\u003cjson\u003e res \u003d check event.content.ensureType();\n        HubResponse hubResponse \u003d check res.cloneWithType();\n        if hubResponse.labels.indexOf(\"documentation\") is () || hubResponse.action \u003d\u003d \"commented\" || hubResponse.action \u003d\u003d \"closed\" {\n            return;\n        }\n        int priority;\n        if hubResponse.kind \u003d\u003d \"feature request\" {\n            priority \u003d 3;\n        } else if hubResponse.kind \u003d\u003d \"bug\" {\n            string? severity \u003d hubResponse.severity;\n            if severity is () {\n                return error(\"Unexpected payload\");\n            }\n            priority \u003d priorityMap.get(\"bug\").get(severity);\n        } else {\n            string? impact \u003d hubResponse.impact;\n            if impact is () {\n                return error(\"Unexpected payload.\");\n            }\n            priority \u003d priorityMap.get(\"improvement\").get(impact);\n        }\n        if hubResponse.action \u003d\u003d \"opened\" || (hubResponse.action \u003d\u003d \"labeled\" \u0026\u0026 hubResponse.new_label \u003d\u003d \"documentation\") {\n            discussionDetails.add({priority, affectedVersion: hubResponse.\u0027version, kind: hubResponse.kind, title: hubResponse.title});\n        }\n        log:printInfo(\"Discussion Details\", info \u003d discussionDetails.toArray());\n    }\n}\n\ntable\u003cDiscussionDetails\u003e discussionDetails \u003d table [];\n\nmap\u003cmap\u003cint\u003e\u003e priorityMap \u003d {\n    \"bug\": {\n        \"high\": 1,\n        \"medium\": 2,\n        \"low\": 3\n    },\n    \"improvement\": {\n        \"significant\": 2,\n        \"low\": 3\n    }\n};"}]},{"name":"problem_7_1.hub","coveredLines":113,"missedLines":38,"coveragePercentage":74.83,"sourceFiles":[{"name":"in_memory_hub.bal","coveredLines":[26,27,29,32,33,34,35,38,39,42,43,44,45,46,47,49,56,57,59,60,61,62,66,67,69,70,71,72,73,78,79,80,81,83,84,85,88,89,90,92,96,97,98,102,109,110,111,112,115,116,117,118,119,122,124,125,127,129,131,132,133,134,137,140,141,143,144,145,149,150,153,154,157,158,159,162,164,165,166,172,175,176,177,180,181,182,187,188,193,195,196,223,224,226,229,231,232,233,236,238,242,253,254,257,258,259,261,262,265,267,268,269,280],"missedLines":[36,37,53,93,99,104,170,184,189,190,199,200,201,204,205,207,208,209,210,214,215,218,220,243,245,246,248,250,251,255,263,271,272,273,275,277,278,279],"coveragePercentage":74.83,"sourceCode":"import ballerina/http;\nimport ballerina/log;\nimport ballerina/task;\nimport ballerina/time;\nimport ballerina/websubhub;\n\nisolated map\u003cwebsubhub:Subscription[]\u003e subscriptions \u003d {};\n\ntype ClientDetails [string, websubhub:HubClient];\n\nisolated map\u003cClientDetails[]\u003e dispatcherClients \u003d {\n    [BUGS_TOPIC] : [],\n    [IMPROVEMENTS_TOPIC] : [],\n    [FEATURE_REQUESTS_TOPIC] : [],\n    [ALL_TOPIC] : []\n};\n\nconst ALL_TOPIC \u003d \"http://projzone.com/gofigure/Connectors/events/all.json\";\nconst BUGS_TOPIC \u003d \"http://projzone.com/gofigure/Connectors/events/bugs.json\";\nconst IMPROVEMENTS_TOPIC \u003d \"http://projzone.com/gofigure/Connectors/events/improvements.json\";\nconst FEATURE_REQUESTS_TOPIC \u003d \"http://projzone.com/gofigure/Connectors/events/featurerequests.json\";\n\nfinal string[] \u0026 readonly individualTopics \u003d [BUGS_TOPIC, IMPROVEMENTS_TOPIC, FEATURE_REQUESTS_TOPIC];\n\npublic function startMessageConsumption() {\n    foreach string topic in individualTopics {\n        _ \u003d @strand {thread: \"any\"} start consumeMessages(topic);\n    }\n}\n\npublic function syncDispatcherState() returns error? {\n    while true {\n        foreach string topic in individualTopics {\n            readonly \u0026 websubhub:Subscription[]? subscribers \u003d retrieveAvailableSubscriptions(topic);\n            if subscribers is () {\n                lock {\n                    dispatcherClients[topic] \u003d [];\n                }\n                continue;\n            }\n\n            lock {\n                ClientDetails[] clientDetails \u003d retrieveValidClientDetails(subscribers, dispatcherClients.get(topic));\n                readonly \u0026 websubhub:Subscription[] newSubscribers \u003d retrieveNewSubscribers(subscribers, clientDetails);\n                foreach var subscriber in newSubscribers {\n                    websubhub:HubClient clientEp \u003d check new (subscriber);\n                    clientDetails.push([subscriber.hubCallback, clientEp]);\n                }\n                dispatcherClients[topic] \u003d clientDetails;\n            }\n        }\n    }\n}\n\nisolated function retrieveValidClientDetails(websubhub:Subscription[] activeSubscriptions, ClientDetails[] currentClientDetails) returns ClientDetails[] {\n    string[] availableCallbacks \u003d from websubhub:Subscription subscription in activeSubscriptions\n        select subscription.hubCallback;\n\n    return from ClientDetails clientDetails in currentClientDetails\n        where availableCallbacks.indexOf(clientDetails[0]) is int\n        select clientDetails;\n}\n\nisolated function retrieveNewSubscribers(websubhub:Subscription[] activeSubscriptions, ClientDetails[] currentClientDetails)\n        returns readonly \u0026 websubhub:Subscription[] {\n    string[] currentCallbacks \u003d from [string, websubhub:HubClient] [callback, _] in currentClientDetails\n        select callback;\n\n    websubhub:Subscription[] newSubscriptions \u003d from websubhub:Subscription subscription in activeSubscriptions\n        where currentCallbacks.indexOf(subscription.hubCallback) is ()\n        select subscription;\n    return newSubscriptions.cloneReadOnly();\n}\n\n// TODO: check how we can improve this while also maintaining message order to an acceptable extent.\n// Currently seems to lock dispatcherClients.\nfunction consumeMessages(string topic) {\n    while true {\n        readonly \u0026 websubhub:UpdateMessage? message \u003d poll(topic);\n        if message is () {\n            continue;\n        }\n        readonly \u0026 websubhub:ContentDistributionMessage payload \u003d {\n            contentType: message.contentType,\n            content: message.content\n        };\n\n        lock {\n            foreach ClientDetails clientDetails in dispatcherClients.get(topic) {\n                string callback \u003d clientDetails[0];\n\n                if !isSubscriptionAvailable(topic, callback) {\n                    continue;\n                }\n\n                websubhub:HubClient clientEp \u003d clientDetails[1];\n                websubhub:ContentDistributionSuccess|error response \u003d clientEp-\u003enotifyContentDistribution(payload);\n                if response is websubhub:SubscriptionDeletedError {\n                    removeSubscription(topic, callback);\n                }\n            }\n        }\n    }\n}\n\nisolated websubhub:UpdateMessage[] queue \u003d [];\n\npublic isolated function enqueue(readonly \u0026 websubhub:UpdateMessage message) {\n    lock {\n        queue.push(message);\n    }\n}\n\npublic function dequeue(string topic) returns readonly \u0026 websubhub:UpdateMessage? {\n    lock {\n        int? index \u003d ();\n        foreach [int, websubhub:UpdateMessage] [messageIndex, message] in queue.enumerate() {\n            if message.hubTopic !\u003d topic {\n                continue;\n            }\n\n            index \u003d messageIndex;\n        }\n        if index is () {\n            return;\n        }\n        return queue.remove(index).cloneReadOnly();\n    }\n}\n\npublic function poll(string topic, decimal timeout \u003d 10.0) returns readonly \u0026 websubhub:UpdateMessage? {\n    readonly \u0026 websubhub:UpdateMessage? message \u003d dequeue(topic);\n    if message is websubhub:UpdateMessage {\n        return message;\n    }\n\n    time:Utc expiryTime \u003d time:utcAddSeconds(time:utcNow(), timeout);\n\n    // https://github.com/ballerina-platform/ballerina-lang/issues/33535\n    while message is () \u0026\u0026 time:utcDiffSeconds(expiryTime, time:utcNow()) \u003e 0D {\n        message \u003d dequeue(topic);\n\n        lock {\n            if queue.length() \u003d\u003d 0 {\n                break;\n            }\n        }\n    }\n    return message;\n}\n\npublic isolated function isTopicAvailable(string topic) returns boolean {\n    return topic \u003d\u003d ALL_TOPIC || individualTopics.indexOf(topic) !is ();\n}\n\npublic isolated function isSubscriptionAvailable(string topic, string hubCallback) returns boolean {\n    lock {\n        if !subscriptions.hasKey(topic) {\n            return false;\n        }\n\n        websubhub:Subscription[] topicSubscriptions \u003d subscriptions.get(topic);\n\n        foreach websubhub:Subscription subscription in topicSubscriptions {\n            if subscription.hubCallback \u003d\u003d hubCallback {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n\npublic isolated function addSubscription(readonly \u0026 websubhub:Subscription subscriber) {\n    log:printInfo(\"Adding subscription\", topic \u003d subscriber.hubTopic, callback \u003d subscriber.hubCallback);\n    string topic \u003d subscriber.hubTopic;\n    lock {\n        string[] topics;\n\n        if topic \u003d\u003d ALL_TOPIC {\n            topics \u003d [];\n            topics.push(...individualTopics);\n        } else {\n            topics \u003d [topic];\n        }\n\n        foreach string relevantTopic in topics {\n            if subscriptions.hasKey(relevantTopic) {\n                subscriptions.get(relevantTopic).push(subscriber);\n                continue;\n            }\n\n            subscriptions[relevantTopic] \u003d [subscriber];\n        }\n    }\n}\n\npublic isolated function removeSubscription(string topic, string hubCallback) {\n    lock {\n        if !subscriptions.hasKey(topic) {\n            return;\n        }\n\n        websubhub:Subscription[] topicSubscriptions \u003d subscriptions.get(topic);\n        int? index \u003d ();\n\n        foreach [int, websubhub:Subscription] [subscriptionIndex, subscription] in topicSubscriptions.enumerate() {\n            if subscription.hubCallback \u003d\u003d hubCallback {\n                index \u003d subscriptionIndex;\n                break;\n            }\n        }\n\n        if index is () {\n            return;\n        }\n\n        _ \u003d topicSubscriptions.remove(index);\n    }\n}\n\npublic function retrieveAvailableSubscriptions(string topic) returns readonly \u0026 websubhub:Subscription[]? {\n    lock {\n        return subscriptions[topic].cloneReadOnly();\n    }\n}\n\nfunction init() returns error? {\n    task:Job job \u003d object {\n        public function execute() {\n            startMessageConsumption();\n            _ \u003d @strand {thread: \"any\"} start syncDispatcherState();\n        }\n    };\n\n    _ \u003d check task:scheduleOneTimeJob(job, time:utcToCivil(time:utcAddSeconds(time:utcNow(), 3)));\n\n}\n\nconfigurable int hubPort \u003d 9090;\n\nisolated service \"hub\" on new websubhub:Listener(hubPort) {\n    remote function onRegisterTopic(readonly \u0026 websubhub:TopicRegistration message)\n                                returns websubhub:TopicRegistrationSuccess|websubhub:TopicRegistrationError {\n        return error(\"Topics are fixed.\", statusCode \u003d http:STATUS_BAD_REQUEST);\n    }\n\n    remote function onDeregisterTopic(readonly \u0026 websubhub:TopicDeregistration message)\n                                returns websubhub:TopicDeregistrationSuccess|websubhub:TopicDeregistrationError {\n        return error(\"Topics are fixed.\", statusCode \u003d http:STATUS_BAD_REQUEST);\n    }\n\n    isolated remote function onUpdateMessage(readonly \u0026 websubhub:UpdateMessage message) returns websubhub:Acknowledgement|websubhub:UpdateMessageError {\n        if !isTopicAvailable(message.hubTopic) {\n            return websubhub:UPDATE_MESSAGE_ERROR;\n        }\n        enqueue(message);\n        return websubhub:ACKNOWLEDGEMENT;\n    }\n\n    isolated remote function onSubscriptionValidation(readonly \u0026 websubhub:Subscription message) returns websubhub:SubscriptionDeniedError? {\n        if !isTopicAvailable(message.hubTopic) || isSubscriptionAvailable(message.hubTopic, message.hubCallback) {\n            return websubhub:SUBSCRIPTION_DENIED_ERROR;\n        }\n    }\n\n    isolated remote function onSubscriptionIntentVerified(readonly \u0026 websubhub:VerifiedSubscription message) returns error? {\n        addSubscription(message);\n    }\n\n    isolated remote function onUnsubscriptionValidation(readonly \u0026 websubhub:Unsubscription message) returns websubhub:UnsubscriptionDeniedError? {\n        if !isTopicAvailable(message.hubTopic) || !isSubscriptionAvailable(message.hubTopic, message.hubCallback) {\n            return websubhub:UNSUBSCRIPTION_DENIED_ERROR;\n        }\n    }\n\n    isolated remote function onUnsubscriptionIntentVerified(readonly \u0026 websubhub:VerifiedUnsubscription message) returns error? {\n        removeSubscription(message.hubTopic, message.hubCallback);\n    }\n}\n"}]}]}